input {
  file {
    path => "/app/logs/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "json"
    tags => ["hexstrike", "security"]
  }
  
  beats {
    port => 5044
  }
  
  http {
    port => 8080
    codec => "json"
    tags => ["webhook", "api"]
  }
}

filter {
  if "hexstrike" in [tags] {
    # Parse HexStrike AI log format
    if [message] =~ /^\[.*\]/ {
      grok {
        match => { 
          "message" => "\[%{TIMESTAMP_ISO8601:timestamp}\] %{LOGLEVEL:level} %{GREEDYDATA:log_message}" 
        }
      }
    }
    
    # Extract security tool information
    if [tool_name] {
      mutate {
        add_field => { "security_tool" => "%{tool_name}" }
      }
    }
    
    # Parse vulnerability information
    if [vulnerability] {
      json {
        source => "vulnerability"
        target => "vuln_details"
      }
    }
    
    # Add risk scoring
    if [severity] {
      if [severity] == "critical" {
        mutate { add_field => { "risk_score" => 10 } }
      } else if [severity] == "high" {
        mutate { add_field => { "risk_score" => 8 } }
      } else if [severity] == "medium" {
        mutate { add_field => { "risk_score" => 5 } }
      } else if [severity] == "low" {
        mutate { add_field => { "risk_score" => 2 } }
      } else {
        mutate { add_field => { "risk_score" => 1 } }
      }
    }
    
    # GeoIP enrichment for IP addresses
    if [target_ip] {
      geoip {
        source => "target_ip"
        target => "geoip"
      }
    }
    
    # Add threat intelligence tags
    if [indicators] {
      ruby {
        code => "
          indicators = event.get('indicators')
          if indicators.is_a?(Array)
            event.set('threat_intel_match', true)
            event.set('ioc_count', indicators.length)
          end
        "
      }
    }
  }
  
  # Parse API logs
  if "api" in [tags] {
    if [request] {
      json {
        source => "request"
        target => "api_request"
      }
    }
    
    if [response] {
      json {
        source => "response"
        target => "api_response"
      }
    }
  }
  
  # Add timestamp
  date {
    match => [ "timestamp", "ISO8601" ]
  }
  
  # Remove unnecessary fields
  mutate {
    remove_field => [ "host", "path", "@version" ]
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "hexstrike-logs-%{+YYYY.MM.dd}"
    template_name => "hexstrike"
    template => "/usr/share/logstash/templates/hexstrike-template.json"
    template_overwrite => true
  }
  
  # Send critical vulnerabilities to alerting
  if [severity] == "critical" {
    http {
      url => "http://hexstrike-ai:8888/api/alerts/webhook"
      http_method => "post"
      format => "json"
      mapping => {
        "alert_type" => "critical_vulnerability"
        "severity" => "%{severity}"
        "target" => "%{target}"
        "vulnerability" => "%{vuln_details}"
        "timestamp" => "%{@timestamp}"
      }
    }
  }
  
  # Debug output
  if [debug] {
    stdout { codec => rubydebug }
  }
}