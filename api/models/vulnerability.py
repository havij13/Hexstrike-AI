"""
Vulnerability Model

This module contains the Vulnerability data model and related functionality.
"""

from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum


class VulnerabilitySeverity(Enum):
    """Vulnerability severity enumeration"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityStatus(Enum):
    """Vulnerability status enumeration"""
    OPEN = "open"
    CONFIRMED = "confirmed"
    FALSE_POSITIVE = "false_positive"
    FIXED = "fixed"
    ACCEPTED_RISK = "accepted_risk"
    DUPLICATE = "duplicate"


@dataclass
class VulnerabilityReference:
    """Vulnerability reference (CVE, CWE, etc.)"""
    type: str  # cve, cwe, owasp, etc.
    id: str
    url: Optional[str] = None


@dataclass
class VulnerabilityEvidence:
    """Evidence for vulnerability"""
    request: Optional[str] = None
    response: Optional[str] = None
    payload: Optional[str] = None
    screenshot: Optional[str] = None
    additional_data: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Vulnerability:
    """Vulnerability data model"""
    id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    status: VulnerabilityStatus
    scan_id: str
    tool: str
    target: str
    url: Optional[str] = None
    parameter: Optional[str] = None
    cvss_score: Optional[float] = None
    cvss_vector: Optional[str] = None
    cwe_id: Optional[str] = None
    owasp_category: Optional[str] = None
    references: List[VulnerabilityReference] = field(default_factory=list)
    evidence: Optional[VulnerabilityEvidence] = None
    remediation: Optional[str] = None
    impact: Optional[str] = None
    likelihood: Optional[str] = None
    confidence: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    verified_at: Optional[datetime] = None
    fixed_at: Optional[datetime] = None
    tags: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert vulnerability to dictionary for JSON serialization"""
        return {
            'id': self.id,
            'title': self.title,
            'description': self.description,
            'severity': self.severity.value if isinstance(self.severity, VulnerabilitySeverity) else self.severity,
            'status': self.status.value if isinstance(self.status, VulnerabilityStatus) else self.status,
            'scan_id': self.scan_id,
            'tool': self.tool,
            'target': self.target,
            'url': self.url,
            'parameter': self.parameter,
            'cvss_score': self.cvss_score,
            'cvss_vector': self.cvss_vector,
            'cwe_id': self.cwe_id,
            'owasp_category': self.owasp_category,
            'references': [self._serialize_reference(ref) for ref in self.references],
            'evidence': self._serialize_evidence(),
            'remediation': self.remediation,
            'impact': self.impact,
            'likelihood': self.likelihood,
            'confidence': self.confidence,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'verified_at': self.verified_at.isoformat() if self.verified_at else None,
            'fixed_at': self.fixed_at.isoformat() if self.fixed_at else None,
            'tags': self.tags,
            'metadata': self.metadata
        }

    def _serialize_reference(self, ref: VulnerabilityReference) -> Dict[str, Any]:
        """Serialize vulnerability reference"""
        return {
            'type': ref.type,
            'id': ref.id,
            'url': ref.url
        }

    def _serialize_evidence(self) -> Optional[Dict[str, Any]]:
        """Serialize vulnerability evidence"""
        if not self.evidence:
            return None
        
        return {
            'request': self.evidence.request,
            'response': self.evidence.response,
            'payload': self.evidence.payload,
            'screenshot': self.evidence.screenshot,
            'additional_data': self.evidence.additional_data
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Vulnerability':
        """Create Vulnerability instance from dictionary"""
        # Parse references
        references = []
        for ref_data in data.get('references', []):
            references.append(VulnerabilityReference(
                type=ref_data['type'],
                id=ref_data['id'],
                url=ref_data.get('url')
            ))

        # Parse evidence
        evidence = None
        if data.get('evidence'):
            evidence_data = data['evidence']
            evidence = VulnerabilityEvidence(
                request=evidence_data.get('request'),
                response=evidence_data.get('response'),
                payload=evidence_data.get('payload'),
                screenshot=evidence_data.get('screenshot'),
                additional_data=evidence_data.get('additional_data', {})
            )

        return cls(
            id=data['id'],
            title=data['title'],
            description=data['description'],
            severity=VulnerabilitySeverity(data['severity']) if isinstance(data['severity'], str) else data['severity'],
            status=VulnerabilityStatus(data['status']) if isinstance(data['status'], str) else data['status'],
            scan_id=data['scan_id'],
            tool=data['tool'],
            target=data['target'],
            url=data.get('url'),
            parameter=data.get('parameter'),
            cvss_score=data.get('cvss_score'),
            cvss_vector=data.get('cvss_vector'),
            cwe_id=data.get('cwe_id'),
            owasp_category=data.get('owasp_category'),
            references=references,
            evidence=evidence,
            remediation=data.get('remediation'),
            impact=data.get('impact'),
            likelihood=data.get('likelihood'),
            confidence=data.get('confidence'),
            created_at=datetime.fromisoformat(data['created_at']) if data.get('created_at') else None,
            updated_at=datetime.fromisoformat(data['updated_at']) if data.get('updated_at') else None,
            verified_at=datetime.fromisoformat(data['verified_at']) if data.get('verified_at') else None,
            fixed_at=datetime.fromisoformat(data['fixed_at']) if data.get('fixed_at') else None,
            tags=data.get('tags', []),
            metadata=data.get('metadata', {})
        )

    def is_critical(self) -> bool:
        """Check if vulnerability is critical severity"""
        return self.severity == VulnerabilitySeverity.CRITICAL

    def is_high_severity(self) -> bool:
        """Check if vulnerability is high or critical severity"""
        return self.severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH]

    def is_open(self) -> bool:
        """Check if vulnerability is still open"""
        return self.status == VulnerabilityStatus.OPEN

    def is_fixed(self) -> bool:
        """Check if vulnerability is fixed"""
        return self.status == VulnerabilityStatus.FIXED

    def is_false_positive(self) -> bool:
        """Check if vulnerability is marked as false positive"""
        return self.status == VulnerabilityStatus.FALSE_POSITIVE

    def get_severity_score(self) -> int:
        """Get numeric severity score for sorting"""
        severity_scores = {
            VulnerabilitySeverity.CRITICAL: 5,
            VulnerabilitySeverity.HIGH: 4,
            VulnerabilitySeverity.MEDIUM: 3,
            VulnerabilitySeverity.LOW: 2,
            VulnerabilitySeverity.INFO: 1
        }
        return severity_scores.get(self.severity, 0)

    def add_reference(self, ref_type: str, ref_id: str, url: Optional[str] = None):
        """Add vulnerability reference"""
        reference = VulnerabilityReference(type=ref_type, id=ref_id, url=url)
        self.references.append(reference)
        self.updated_at = datetime.utcnow()

    def add_tag(self, tag: str):
        """Add tag to vulnerability"""
        if tag not in self.tags:
            self.tags.append(tag)
            self.updated_at = datetime.utcnow()

    def remove_tag(self, tag: str):
        """Remove tag from vulnerability"""
        if tag in self.tags:
            self.tags.remove(tag)
            self.updated_at = datetime.utcnow()

    def set_metadata(self, key: str, value: Any):
        """Set metadata"""
        self.metadata[key] = value
        self.updated_at = datetime.utcnow()

    def get_metadata(self, key: str, default: Any = None) -> Any:
        """Get metadata"""
        return self.metadata.get(key, default)

    def mark_as_verified(self):
        """Mark vulnerability as verified"""
        self.status = VulnerabilityStatus.CONFIRMED
        self.verified_at = datetime.utcnow()
        self.updated_at = datetime.utcnow()

    def mark_as_false_positive(self):
        """Mark vulnerability as false positive"""
        self.status = VulnerabilityStatus.FALSE_POSITIVE
        self.updated_at = datetime.utcnow()

    def mark_as_fixed(self):
        """Mark vulnerability as fixed"""
        self.status = VulnerabilityStatus.FIXED
        self.fixed_at = datetime.utcnow()
        self.updated_at = datetime.utcnow()

    def set_evidence(self, evidence: VulnerabilityEvidence):
        """Set vulnerability evidence"""
        self.evidence = evidence
        self.updated_at = datetime.utcnow()


class VulnerabilitySerializer:
    """Vulnerability serializer for API responses"""

    @staticmethod
    def serialize(vulnerability: Vulnerability, include_evidence: bool = True) -> Dict[str, Any]:
        """Serialize vulnerability for API response"""
        data = vulnerability.to_dict()
        
        if not include_evidence:
            # Remove detailed evidence for list views
            if 'evidence' in data:
                data['evidence'] = {
                    'has_request': bool(vulnerability.evidence and vulnerability.evidence.request),
                    'has_response': bool(vulnerability.evidence and vulnerability.evidence.response),
                    'has_payload': bool(vulnerability.evidence and vulnerability.evidence.payload),
                    'has_screenshot': bool(vulnerability.evidence and vulnerability.evidence.screenshot)
                }
        
        return data

    @staticmethod
    def serialize_list(vulnerabilities: List[Vulnerability], include_evidence: bool = False) -> List[Dict[str, Any]]:
        """Serialize list of vulnerabilities for API response"""
        return [VulnerabilitySerializer.serialize(vuln, include_evidence) for vuln in vulnerabilities]

    @staticmethod
    def deserialize(data: Dict[str, Any]) -> Vulnerability:
        """Deserialize vulnerability from API request"""
        return Vulnerability.from_dict(data)

    @staticmethod
    def get_severity_distribution(vulnerabilities: List[Vulnerability]) -> Dict[str, int]:
        """Get vulnerability count by severity"""
        distribution = {severity.value: 0 for severity in VulnerabilitySeverity}
        
        for vuln in vulnerabilities:
            severity = vuln.severity.value if isinstance(vuln.severity, VulnerabilitySeverity) else vuln.severity
            if severity in distribution:
                distribution[severity] += 1
        
        return distribution

    @staticmethod
    def get_status_distribution(vulnerabilities: List[Vulnerability]) -> Dict[str, int]:
        """Get vulnerability count by status"""
        distribution = {status.value: 0 for status in VulnerabilityStatus}
        
        for vuln in vulnerabilities:
            status = vuln.status.value if isinstance(vuln.status, VulnerabilityStatus) else vuln.status
            if status in distribution:
                distribution[status] += 1
        
        return distribution