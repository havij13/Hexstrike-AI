"""
Vulnerability Correlator Agent

This module provides vulnerability analysis and correlation capabilities.
"""

import time
from typing import Dict, Any, List, Optional
from .base_agent import BaseAgent, AgentResult, AgentStatus


class VulnerabilityCorrelator(BaseAgent):
    """AI-powered vulnerability correlation and analysis agent"""

    def __init__(self, config: Dict[str, Any] = None):
        super().__init__("VulnerabilityCorrelator", config)
        
        self.vulnerability_patterns = {
            "sql_injection": {
                "indicators": ["sql", "injection", "union", "select", "database"],
                "severity": "high",
                "tools": ["sqlmap", "nuclei"],
                "remediation": "Use parameterized queries and input validation"
            },
            "xss": {
                "indicators": ["script", "javascript", "alert", "onerror", "onload"],
                "severity": "medium",
                "tools": ["dalfox", "nuclei"],
                "remediation": "Implement proper output encoding and CSP"
            },
            "rce": {
                "indicators": ["command", "execution", "system", "exec", "shell"],
                "severity": "critical",
                "tools": ["nuclei", "jaeles"],
                "remediation": "Avoid system calls with user input, use sandboxing"
            },
            "ssrf": {
                "indicators": ["server", "side", "request", "forgery", "internal"],
                "severity": "high",
                "tools": ["nuclei", "ffuf"],
                "remediation": "Validate and whitelist allowed URLs"
            },
            "lfi": {
                "indicators": ["local", "file", "inclusion", "path", "traversal"],
                "severity": "medium",
                "tools": ["ffuf", "nuclei"],
                "remediation": "Validate file paths and use absolute paths"
            }
        }

        self.severity_scores = {
            "critical": 10,
            "high": 7,
            "medium": 5,
            "low": 3,
            "info": 1
        }

    async def execute(self, target: str, parameters: Dict[str, Any] = None) -> AgentResult:
        """Execute vulnerability correlation analysis"""
        start_time = time.time()
        self.set_status(AgentStatus.RUNNING)
        
        try:
            if not parameters:
                parameters = {}
            
            analysis_type = parameters.get("analysis_type", "correlation")
            vulnerabilities = parameters.get("vulnerabilities", [])
            
            if analysis_type == "correlation":
                result_data = self.correlate_vulnerabilities(vulnerabilities)
            elif analysis_type == "risk_assessment":
                result_data = self.assess_risk(vulnerabilities)
            elif analysis_type == "remediation":
                result_data = self.generate_remediation_plan(vulnerabilities)
            else:
                result_data = self.correlate_vulnerabilities(vulnerabilities)
            
            execution_time = time.time() - start_time
            self.set_status(AgentStatus.COMPLETED)
            
            result = AgentResult(
                success=True,
                data=result_data,
                message=f"Vulnerability {analysis_type} completed successfully",
                status=AgentStatus.COMPLETED,
                execution_time=execution_time
            )
            
            self.add_result(result)
            return result
            
        except Exception as e:
            execution_time = time.time() - start_time
            self.set_status(AgentStatus.FAILED)
            
            result = AgentResult(
                success=False,
                data={},
                message=f"Vulnerability analysis failed: {str(e)}",
                status=AgentStatus.FAILED,
                execution_time=execution_time,
                errors=[str(e)]
            )
            
            self.add_result(result)
            return result

    def validate_parameters(self, parameters: Dict[str, Any]) -> bool:
        """Validate input parameters"""
        if not parameters:
            return True
        
        valid_analysis_types = ["correlation", "risk_assessment", "remediation"]
        analysis_type = parameters.get("analysis_type", "correlation")
        
        return analysis_type in valid_analysis_types

    def get_capabilities(self) -> List[str]:
        """Get list of agent capabilities"""
        return [
            "vulnerability_correlation",
            "risk_assessment",
            "remediation_planning",
            "severity_analysis",
            "attack_chain_analysis"
        ]

    def correlate_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Correlate vulnerabilities to identify patterns and relationships"""
        correlation_result = {
            "total_vulnerabilities": len(vulnerabilities),
            "severity_distribution": {},
            "vulnerability_types": {},
            "correlated_chains": [],
            "risk_score": 0.0,
            "recommendations": []
        }

        # Analyze severity distribution
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "unknown").lower()
            correlation_result["severity_distribution"][severity] = \
                correlation_result["severity_distribution"].get(severity, 0) + 1

        # Analyze vulnerability types
        for vuln in vulnerabilities:
            vuln_type = self._classify_vulnerability(vuln)
            correlation_result["vulnerability_types"][vuln_type] = \
                correlation_result["vulnerability_types"].get(vuln_type, 0) + 1

        # Identify attack chains
        correlation_result["correlated_chains"] = self._identify_attack_chains(vulnerabilities)

        # Calculate overall risk score
        correlation_result["risk_score"] = self._calculate_risk_score(vulnerabilities)

        # Generate recommendations
        correlation_result["recommendations"] = self._generate_recommendations(vulnerabilities)

        return correlation_result

    def assess_risk(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Assess overall risk based on vulnerabilities"""
        risk_assessment = {
            "overall_risk": "unknown",
            "risk_score": 0.0,
            "critical_vulnerabilities": [],
            "high_risk_combinations": [],
            "business_impact": {},
            "likelihood": {},
            "mitigation_priority": []
        }

        # Calculate risk score
        total_score = 0
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "low").lower()
            score = self.severity_scores.get(severity, 1)
            total_score += score

        risk_assessment["risk_score"] = total_score / len(vulnerabilities) if vulnerabilities else 0

        # Determine overall risk level
        if risk_assessment["risk_score"] >= 8:
            risk_assessment["overall_risk"] = "critical"
        elif risk_assessment["risk_score"] >= 6:
            risk_assessment["overall_risk"] = "high"
        elif risk_assessment["risk_score"] >= 4:
            risk_assessment["overall_risk"] = "medium"
        else:
            risk_assessment["overall_risk"] = "low"

        # Identify critical vulnerabilities
        risk_assessment["critical_vulnerabilities"] = [
            vuln for vuln in vulnerabilities 
            if vuln.get("severity", "").lower() in ["critical", "high"]
        ]

        # Identify high-risk combinations
        risk_assessment["high_risk_combinations"] = self._identify_high_risk_combinations(vulnerabilities)

        # Assess business impact
        risk_assessment["business_impact"] = self._assess_business_impact(vulnerabilities)

        # Create mitigation priority list
        risk_assessment["mitigation_priority"] = self._prioritize_mitigation(vulnerabilities)

        return risk_assessment

    def generate_remediation_plan(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate comprehensive remediation plan"""
        remediation_plan = {
            "immediate_actions": [],
            "short_term_actions": [],
            "long_term_actions": [],
            "estimated_effort": {},
            "resource_requirements": {},
            "timeline": {}
        }

        # Sort vulnerabilities by severity and impact
        sorted_vulns = sorted(
            vulnerabilities,
            key=lambda v: self.severity_scores.get(v.get("severity", "low").lower(), 1),
            reverse=True
        )

        for vuln in sorted_vulns:
            vuln_type = self._classify_vulnerability(vuln)
            severity = vuln.get("severity", "low").lower()
            
            remediation_info = self.vulnerability_patterns.get(vuln_type, {})
            remediation = remediation_info.get("remediation", "Review and fix vulnerability")

            action = {
                "vulnerability": vuln.get("name", "Unknown"),
                "type": vuln_type,
                "severity": severity,
                "remediation": remediation,
                "estimated_effort": self._estimate_remediation_effort(vuln_type, severity),
                "tools_needed": remediation_info.get("tools", [])
            }

            # Categorize by urgency
            if severity in ["critical", "high"]:
                remediation_plan["immediate_actions"].append(action)
            elif severity == "medium":
                remediation_plan["short_term_actions"].append(action)
            else:
                remediation_plan["long_term_actions"].append(action)

        # Calculate overall estimates
        remediation_plan["estimated_effort"] = self._calculate_total_effort(remediation_plan)
        remediation_plan["resource_requirements"] = self._calculate_resource_requirements(remediation_plan)
        remediation_plan["timeline"] = self._create_remediation_timeline(remediation_plan)

        return remediation_plan

    def _classify_vulnerability(self, vulnerability: Dict[str, Any]) -> str:
        """Classify vulnerability based on description and indicators"""
        description = vulnerability.get("description", "").lower()
        name = vulnerability.get("name", "").lower()
        
        combined_text = f"{description} {name}"

        for vuln_type, pattern in self.vulnerability_patterns.items():
            indicators = pattern["indicators"]
            if any(indicator in combined_text for indicator in indicators):
                return vuln_type

        return "unknown"

    def _identify_attack_chains(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Identify potential attack chains from vulnerabilities"""
        attack_chains = []

        # Look for common attack chain patterns
        vuln_types = [self._classify_vulnerability(v) for v in vulnerabilities]

        # Information disclosure -> Privilege escalation
        if "lfi" in vuln_types and "rce" in vuln_types:
            attack_chains.append({
                "chain_type": "lfi_to_rce",
                "description": "Local File Inclusion can be chained with RCE for full compromise",
                "severity": "critical",
                "steps": ["Exploit LFI to read sensitive files", "Use information for RCE exploitation"]
            })

        # SQL Injection -> Data exfiltration
        if "sql_injection" in vuln_types:
            attack_chains.append({
                "chain_type": "sqli_data_exfiltration",
                "description": "SQL Injection can lead to complete database compromise",
                "severity": "high",
                "steps": ["Exploit SQL injection", "Extract sensitive data", "Escalate privileges"]
            })

        # XSS -> Session hijacking
        if "xss" in vuln_types:
            attack_chains.append({
                "chain_type": "xss_session_hijacking",
                "description": "XSS can be used to steal session tokens and impersonate users",
                "severity": "medium",
                "steps": ["Exploit XSS vulnerability", "Steal session cookies", "Impersonate victim"]
            })

        return attack_chains

    def _calculate_risk_score(self, vulnerabilities: List[Dict[str, Any]]) -> float:
        """Calculate overall risk score"""
        if not vulnerabilities:
            return 0.0

        total_score = 0
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "low").lower()
            base_score = self.severity_scores.get(severity, 1)
            
            # Adjust score based on exploitability
            exploitability = vuln.get("exploitability", "medium")
            if exploitability == "high":
                base_score *= 1.5
            elif exploitability == "low":
                base_score *= 0.7

            total_score += base_score

        return min(10.0, total_score / len(vulnerabilities))

    def _generate_recommendations(self, vulnerabilities: List[Dict[str, Any]]) -> List[str]:
        """Generate security recommendations"""
        recommendations = []

        vuln_types = [self._classify_vulnerability(v) for v in vulnerabilities]
        
        if "sql_injection" in vuln_types:
            recommendations.append("Implement parameterized queries and input validation")
        
        if "xss" in vuln_types:
            recommendations.append("Implement Content Security Policy (CSP) and output encoding")
        
        if "rce" in vuln_types:
            recommendations.append("Avoid system calls with user input, implement sandboxing")
        
        if "ssrf" in vuln_types:
            recommendations.append("Validate and whitelist allowed URLs for server-side requests")
        
        if "lfi" in vuln_types:
            recommendations.append("Validate file paths and use absolute paths only")

        # General recommendations
        recommendations.extend([
            "Implement regular security testing and code reviews",
            "Keep all software components up to date",
            "Implement proper logging and monitoring",
            "Conduct security awareness training for developers"
        ])

        return recommendations

    def _identify_high_risk_combinations(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Identify high-risk vulnerability combinations"""
        combinations = []
        vuln_types = [self._classify_vulnerability(v) for v in vulnerabilities]

        # Check for dangerous combinations
        if "rce" in vuln_types and "sql_injection" in vuln_types:
            combinations.append({
                "combination": ["rce", "sql_injection"],
                "risk_level": "critical",
                "description": "RCE combined with SQL injection allows complete system compromise"
            })

        if "ssrf" in vuln_types and "rce" in vuln_types:
            combinations.append({
                "combination": ["ssrf", "rce"],
                "risk_level": "critical", 
                "description": "SSRF can be used to access internal services and chain with RCE"
            })

        return combinations

    def _assess_business_impact(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Assess business impact of vulnerabilities"""
        impact = {
            "data_confidentiality": "low",
            "data_integrity": "low", 
            "service_availability": "low",
            "financial_impact": "low",
            "reputation_impact": "low"
        }

        vuln_types = [self._classify_vulnerability(v) for v in vulnerabilities]

        if "sql_injection" in vuln_types or "lfi" in vuln_types:
            impact["data_confidentiality"] = "high"
            impact["financial_impact"] = "medium"

        if "rce" in vuln_types:
            impact["data_integrity"] = "high"
            impact["service_availability"] = "high"
            impact["financial_impact"] = "high"
            impact["reputation_impact"] = "high"

        if "xss" in vuln_types:
            impact["data_confidentiality"] = "medium"
            impact["reputation_impact"] = "medium"

        return impact

    def _prioritize_mitigation(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Prioritize vulnerabilities for mitigation"""
        priority_list = []

        for vuln in vulnerabilities:
            vuln_type = self._classify_vulnerability(vuln)
            severity = vuln.get("severity", "low").lower()
            
            priority_score = self.severity_scores.get(severity, 1)
            
            # Adjust priority based on exploitability
            exploitability = vuln.get("exploitability", "medium")
            if exploitability == "high":
                priority_score += 2
            elif exploitability == "low":
                priority_score -= 1

            priority_list.append({
                "vulnerability": vuln.get("name", "Unknown"),
                "type": vuln_type,
                "severity": severity,
                "priority_score": priority_score,
                "justification": f"Severity: {severity}, Type: {vuln_type}"
            })

        # Sort by priority score (highest first)
        priority_list.sort(key=lambda x: x["priority_score"], reverse=True)
        
        return priority_list

    def _estimate_remediation_effort(self, vuln_type: str, severity: str) -> str:
        """Estimate effort required for remediation"""
        base_efforts = {
            "sql_injection": "medium",
            "xss": "low", 
            "rce": "high",
            "ssrf": "medium",
            "lfi": "medium"
        }

        base_effort = base_efforts.get(vuln_type, "medium")
        
        # Adjust based on severity
        if severity == "critical":
            if base_effort == "low":
                return "medium"
            elif base_effort == "medium":
                return "high"
            else:
                return "very_high"
        
        return base_effort

    def _calculate_total_effort(self, remediation_plan: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate total remediation effort"""
        effort_mapping = {"low": 1, "medium": 3, "high": 5, "very_high": 8}
        
        total_effort = 0
        for category in ["immediate_actions", "short_term_actions", "long_term_actions"]:
            for action in remediation_plan[category]:
                effort = action.get("estimated_effort", "medium")
                total_effort += effort_mapping.get(effort, 3)

        return {
            "total_effort_points": total_effort,
            "estimated_weeks": max(1, total_effort // 5),
            "complexity": "high" if total_effort > 20 else "medium" if total_effort > 10 else "low"
        }

    def _calculate_resource_requirements(self, remediation_plan: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate resource requirements for remediation"""
        return {
            "security_engineers": 1 if remediation_plan["immediate_actions"] else 0,
            "developers": len(remediation_plan["immediate_actions"]) + len(remediation_plan["short_term_actions"]),
            "qa_testers": 1,
            "external_consultants": 1 if len(remediation_plan["immediate_actions"]) > 5 else 0
        }

    def _create_remediation_timeline(self, remediation_plan: Dict[str, Any]) -> Dict[str, Any]:
        """Create remediation timeline"""
        return {
            "immediate_phase": "1-2 weeks",
            "short_term_phase": "2-6 weeks", 
            "long_term_phase": "6-12 weeks",
            "total_duration": "3-4 months"
        }